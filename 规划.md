

### **第 1 天：底座工程——模型解析、参数读写与数据对齐**

**目标：** 让代码读懂机器人。打通从配置文件（URDF/Info）到内存变量（Eigen）的通路。

* **核心任务：**
1. **解析 OCS2 任务文件 (`task.info`)**：
* 学习使用 `boost::property_tree` 读取配置文件。
* 提取核心参数：关节映射顺序（Joint Names）、足端名称（Contact Names）、初始位姿。


2. **构建 Pinocchio 物理引擎接口**：
* 实现从 `robot_description`（URDF 字符串）加载 `PinocchioInterface`。
* 理解 `CentroidalModelInfo`：搞清楚 36 维状态向量中每一位在物理模型中的具体含义。


3. **数据桥梁（Bridge）适配**：
* 确保 `DogDataBridge` 里的硬件原始数据（12 关节角度、速度、IMU）能与状态估计器的输入完全对齐。




* **理解重点：**
* 为什么 OCS2 必须知道关节顺序？（避免运动学推导时左右反转）。
* `rbdState_36` 的 0-35 位是如何分配给姿态、位置、关节、速度的。


* **今日产出：** 完整的 `StateEstimatorBase::init()` 函数，能够根据配置文件自动加载模型并分配内存。

---

### **第 2 天：上帝视角——TopicEstimator 与空间几何变换**

**目标：** 实现基于真值的话题订阅，攻克四足机器人最核心的坐标系转换逻辑。

* **核心任务：**
1. **编写 `TopicEstimator` 子类**：
* 实现对 Gazebo P3D 插件话题（`/ground_truth`）的订阅与解析。


2. **攻克坐标系转换（难点）**：
* **姿态转换**：将四元数转换为 OCS2 要求的 ZYX 欧拉角。
* **速度投影**：将机体坐标系速度（Base-Link Frame）转换到世界对齐坐标系（World-aligned Frame）。


3. **链路闭环验证**：
* 将解析出的数据填入 `results.rbdState_36`。
* 在 RViz 中观察估计出的坐标轴是否随仿真狗的移动而完美同步。




* **理解重点：**
*  的几何意义。
* 为什么线速度必须转到世界系，而角速度通常留在机体系？


* **今日产出：** 一个高精度、无延迟的“真值估计器”，作为后续卡尔曼滤波的对标基准（Ground Truth）。

---

### **第 3 天：数学建模——线性卡尔曼滤波（LKF）预测步**

**目标：** 建立 LKF 的数学模型，实现基于 IMU 的自主位姿推算。

* **核心任务：**
1. **LKF 状态空间定义**：
* 定义 18 维状态向量 。


2. **构建系统矩阵**：
* 编写状态转移矩阵 （描述位移=速度×时间）和输入矩阵 （处理加速度）。


3. **实现“预测步”（Predict）**：
* 读取 IMU 加速度，进行二次积分得到位置。
* 初始化过程噪声矩阵 （描述 IMU 到底有多不准）。




* **理解重点：**
* 卡尔曼滤波如何通过加速度预测下一时刻的位置。
* 为什么只靠 IMU 积分，位置会在几秒钟内迅速“飞走”（漂移原理）。


* **今日产出：** 能够根据 IMU 动起来的滤波器，虽然现在它会随时间产生严重的位移漂移。

---

### **第 4 天：物理约束——LKF 观测修正与多算法联调**

**目标：** 利用“足端不滑动”约束消除漂移，完成两种模式的自由切换。

* **核心任务：**
1. **实现“更新步”（Update/Correct）**：
* **运动学观测**：利用关节角计算足端相对于机身的位置。
* **触地约束**：当 `contactFlag` 为真时，强制要求该脚在世界系的速度为 0，以此修正机身的速度和位置。


2. **动态协方差调整**：
* 编写逻辑：根据脚的虚空/踩地状态，动态切换测量噪声矩阵 。


3. **双模切换与对比分析**：
* 在控制器中实现一键切换 `TopicEstimator` 和 `KalmanFilterEstimator`。
* 记录并对比 LKF 估算值与真值话题的偏差。




* **理解重点：**
* 如何利用“脚踩地不能动”这个物理事实来抵消 IMU 的积分误差。
*  和  矩阵如何决定你更相信 IMU 还是更相信腿部运动学。


* **今日产出：** 一个功能完备、鲁棒性强的线性卡尔曼滤波器，为后续 NMPC 的接入扫清障碍。

---

### **💡 成功关键：**

这 4 天里，请务必保持 **“画图习惯”**。

* **位置漂了？** 看一下加速度的重力分量扣除干净没有。
* **速度反了？** 检查  旋转矩阵乘的顺序对不对。
* **机器人炸了？** 确认 12 个关节的顺序和 36 维向量的索引是否一一对应。



---

### 📊 四足机器人控制工程工作量等分表

| 模块                | 原理难度 | 代码体量 | 调参/集成难度 | 权重占比 | 核心痛点                                      |
| ------------------- | -------- | -------- | ------------- | -------- | --------------------------------------------- |
| **MPC (大脑)**      | ⭐⭐⭐⭐⭐    | ⭐⭐⭐⭐     | ⭐⭐⭐⭐          | **40%**  | 最优控制理论、实时性优化、预测窗口逻辑        |
| **WBC (小脑)**      | ⭐⭐⭐⭐     | ⭐⭐⭐⭐⭐    | ⭐⭐⭐           | **35%**  | 任务空间逆动力学 (TSID)、多任务优先级、QP求解 |
| **状态估计 (眼睛)** | ⭐⭐⭐      | ⭐⭐⭐      | ⭐⭐⭐⭐          | **15%**  | 传感器噪声处理、坐标系变换、累积误差消除      |
| **系统集成 (骨骼)** | ⭐⭐       | ⭐⭐⭐⭐     | ⭐⭐⭐           | **10%**  | ROS2 Control 框架、实时性保障、数据同步       |

---

### 1. MPC (Model Predictive Control) —— 占比 40%

这是整个系统的“天花板”。

* **原理难度**：极高。你需要理解非线性优化、变分法（OCS2 核心）、控制时域（Horizon）以及动力学简化模型（如 Single Rigid Body Dynamics）。
* **工作量**：虽然 OCS2 帮你解了最难的数学题，但你需要编写 **Reference Manager（参考轨迹生成器）**，定义各种 **Cost Function（代价函数）** 和 **Constraints（约束）**。
* **耦合点**：它高度依赖 **SE** 提供的当前位置 ，输出给 **WBC** 期望的足端力和未来轨迹。

### 2. WBC (Whole Body Control) —— 占比 35%

这是机器狗走得“稳不稳、丝不丝滑”的关键。

* **原理难度**：高。涉及雅可比矩阵、多任务分层（Hierarchical Control）、以及如何将 MPC 的宏观指令转化成 12 个电机的扭矩。
* **工作量**：代码体量通常是最大的。你需要调用 Pinocchio 进行大量的动力学计算，并手写或调用 QP 求解器（如 OSQP）。
* **耦合点**：它需要 **SE** 的高频反馈（1kHz）来做 PD 补偿，同时紧跟 **MPC** 的步调。

### 3. 状态估计 (State Estimation) —— 占比 15%

这是所有算法的“地基”。

* **原理难度**：中等。核心是卡尔曼滤波（LKF/EKF）或因子图。
* **工作量**：代码相对固定，但**“容错处理”**非常琐碎（比如脚打滑了怎么办？IMU 漂了怎么办？）。
* **耦合点**：它是所有人的输入。如果 SE 抖一下，MPC 会算错，WBC 会踢腿，系统直接崩盘。

### 4. 系统集成与基础设施 —— 占比 10%

这是让代码从“论文”变成“机器人”的过程。

* **工作量**：涉及 `ros2_control` 插件编写、`DogDataBridge` 硬件抽象层、`Xacro` 模型搭建。
* **核心难度**：**实时性（Real-time）**。如果你的代码在 1kHz 循环里卡了 2ms，狗会立刻跪下。

---

### 🔗 模块间的耦合逻辑（为什么难集成？）

整个系统的集成是一个**闭环耦合**：

* **频率耦合**：SE 和 WBC 必须跑在 1kHz 以上，而 MPC 通常跑在 100Hz 左右。如何让 100Hz 的大脑指挥 1000Hz 的肌肉？你需要做**轨迹插值**。
* **坐标系耦合**：这是新手最容易崩溃的地方。MPC 习惯世界系，WBC 习惯机体系，传感器在 IMU 系。只要有一个旋转矩阵  乘反了，狗就会原地起飞。
* **延迟耦合**：计算 MPC 需要时间，等你算出来，机器人已经运动到下一个状态了。你需要做**状态预测补偿**。

---